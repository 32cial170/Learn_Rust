// B_4.1.1

// 所有權可以說是 Rust 最與眾不同的特色，並深深影響著整個語言。這讓 Rust 不需要垃圾回收（garbage collector）就可以保障記憶體安全

// 什麼是所有權？
// 所有權在 Rust 中用來管理程式記憶體的一系列規則。 
// 所有程式都需要在執行時管理它們使用記憶體的方式。
// 有些語言會用垃圾回收機制，在程式執行時不斷尋找不再使用的記憶體； c# jave
// 而有些程式，開發者必須親自分配和釋放記憶體; c c++
// Rust 選擇了第三種方式：記憶體由所有權系統管理，且編譯器會在編譯時加上一些規則檢查。如果有地方違規的話，程式就無法編譯。
// 這些所有權的規則完全不會降低執行程式的速度。(rust把內存管理的相關工作提前到編譯階段)

// 堆疊（Stack）(棧內存)與堆積（Heap）(堆內存)
// 在許多程式語言中，你通常不需要去想到堆疊與堆積。但在像是 Rust 系統程式語言，一個值位於stack或heap 對語言的行為和你為什麼得作出某些特定決策有更大影響
// 在你的code 運行時，堆疊與堆積都是你可用的內存，但他們組成的方式卻不一樣。

// Stack
// 1. stack LIFO
// 2. 所有在stack上的資料都必須是已知固定大小。在編譯時屬於未知或可能變更大小的資料(數據)必須儲存在heap。

// 堆積（Heap）
// 1. 堆積就比較沒有組織
// 2. 當你要將資料放入堆積，你會請求一定大小的空間。
// 記憶體分配器（memory allocator）(os)會找到一塊夠大的空位，標記為已佔用，然後回傳一個指標（pointer），指著該位置的位址。
// 這樣的過程稱為在堆積上分配（allocating on the heap），或者有時直接簡稱為分配（allocating）就好。

// Stack和Heap 存儲資料
// 將數值放入stack不會被視為是在分配
// 因為指標是固定已知的大小，所以你可以存在stack上。
// 但當你要存取實際資料時，你就得去透過指標取得資料。

// 將資料推入stack會比在heap上分配還來的快，因為分配器(os)不需要去搜尋哪邊才能存入新資料，其位置永遠在stack最上方(top)。
// 相對的，heap就需要比較多步驟，分配器必須先找到一個夠大的空位來儲存資料，然後作下紀錄為下次分配做準備。

// Stack和Heap 訪問資料
// 在heap上取得資料也比在stack上取得來得慢，因為你需要用追蹤指標才找的到。
// 現代的處理器如果在記憶體間跳轉越少的話速度就越快。
// 如果處理的資料相鄰很近（就如同存在stack）的話，當然比相鄰很遠（如同存在heap）來得快。
// 在heap上分配大量空間也很花時間的

// Stack和 Heap函數調用
// 當你的程式碼呼叫函式時，函式本地區域變數會被推入stack。當函式結束時，這些數值就會被彈出stack。
// 當你的程式碼呼叫函式時，數值傳遞給函式的（可能包含指向heap的指標）

// 所有權存在的原因
// 1. 所有權解決的問題
//     a. 追蹤哪部分的程式碼正在使用heap上的哪些資料
//     b. 最小化heap上的重複數據量、
//     c. 清除heap上沒在使用的資料確保你不會空間不足
// 一旦你理解所有權後，你通常就不再需要經常考慮stack與heap的問題，但是知道管理heap數據是所有權存在的原因，這有助於解釋為什麼會這樣工作


// B_4.1.2
// 所有權規則
// 首先，讓我們先看看所有權規則。當我們在解釋說明時，請記得這些規則：

//     每個數值都有一個變量(變數)，這個變量是該值的擁有者（owner）。
//     每個值同時間只能有一個擁有者。
//     當擁有者離開作用域(scope)時，數值就會被刪除。

// 變數(變量)作用域
// 作用域Scope 是一些項目在程式內的有效範圍。假設我們有以下變數：
// fn main() {
//     {                      // s 在此處無效，因為它還沒宣告
//         let s = "hello";   // s 在此開始視為有效，s為變量(變數)，"hello"為數值，s的值目前仍存在stack中

//         // 使用 s
//     }                      // 此作用域結束， s 不再有效，即s的值已經pop out of stack
// }

// 要能夠解釋所有權規則，我們需要使用複雜的型別才行
// 前我們提到的型別都是已知固定大小且儲存在堆疊上的，在作用域結束時就會從堆疊中彈出。
// 而且如果其它部分的程式碼需要在不同作用域使用相同數值的話，它們都能迅速簡單地透過複製產生新的單獨實例。
// 但是我們想要觀察的是儲存在堆積上的資料，並研究 Rust 是如何知道要清理資料的。而 String 型別正是個絕佳範例。

// String 型別
// 我們已經看過字串字面值（string literals）(sc:字符串字面值)，字串的數值是寫死在我們的程式內的。
// 字串字面值的確很方便，但它不可能完全適用於我們使用文字時的所有狀況。其中一個原因是因為它是不可變的，另一個原因是並非所有字串值在我們編寫程式時就會知道。舉例來說，要是我們想要收集使用者的輸入並儲存它呢？

// 對於這些情形，Rust 提供第二種字串型別 String。
//     string在heap上分配。能夠儲存我們在編譯期間未知數量文本。

// 創建String類型的值
// 使用 from 函式從字串字面值來建立一個 String類型，如以下所示：

// let s = String::from("hello"); //這裡的hello就是字串字面值
//     1. "::"雙冒號 表示from 是String 類型下的函數
//     2. 這類字符串是可以被修改的，看例子

// fn main() {
//     let mut s = String::from("hello");

//     s.push_str(", world!"); // push_str() 將字面值加到字串後面

//     println!("{}", s); // 這會印出 `hello, world!`
// }

// 為何 String 是可變的，但字面值卻不行？ 兩者最主要的差別在於它們對待記憶體的方式。
// 記憶體與分配

// 以字串字面值來說，我們在編譯時就知道它的內容，所以可以寫死在最終可執行檔內
// 這就是為何字串字面值非常迅速且高效。但這些特性均來自於字串字面值的不可變性。

// 而對於 String 型別來說，為了夠支持可變性、改變文字長度大小，我們需要在heap上分配內存來保存編譯時未知的文本內容，這代表：
//     記憶體分配器(os)必須在執行時(runtime)請求記憶體。
//         這步通過調用String::from來實現
//     我們不再需要這個 String 時，我們需要以某種方法將此記憶體歸還給OS。
//         這步在擁有GC的語言中，GC會跟蹤並清理不再使用的內存，Java C#
//         沒有 GC 的話，識別哪些記憶體不再使用並明確的呼叫程式碼釋放它們就是我們的責任了，就像我們請求取得它一樣。 C C++
//             如果我們忘了，那麼就等於在浪費記憶體。
//             如果我們釋放的太早的話，我們則有可能會拿到無效的(非法)變數
//             要是我們釋放了兩次，那也會造成程式錯誤。
//             們必須準確無誤地配對一個 allocate 給剛好一個 free。

//     Rust 選擇了一條不同的道路：當記憶體的值在擁有它的變數(owner)離開作用域(scope)時就會自動釋放交還給os

// fn main() {
//     {
//         let s = String::from("hello"); // s 在此開始視為有效

//         // 使用 s
//     }                                  // 此作用域結束
//                                        // s 不再有效
// }
// 當變數離開作用域時，Rust 會自動幫我們呼叫一個特殊函式。此函式叫做 drop。Rust 會在大括號結束時自動呼叫 drop。
// 注意：在 C++，這樣在項目生命週期結束時釋放資源的模式，有時被稱為資源取得即初始化（Resource Acquisition Is Initialization, RAII）。如果你已經用過 RAII 的模式，那麼你應該就會很熟悉 Rust 的 drop 函式。
// 雖然現在這樣看起來很簡單，但在更多複雜的情況下程式碼的行為可能會變得很難預測。像是當我們需要許多變數，所以得在heap上分配它們的情況。現在就讓我們開始來探討這些情形。

// 變數與資料互動的方式：移動（Move）
// 多個變數(變量)在 Rust 中可以與同一格數據(資料)用一種獨特方式進行互動。讓我們看看使用整數的範例

// let x = 5;
// let y = x;
// 因為整數是已知且固定大小的簡單數值，所以這兩個數值 5 都會推入stack中。

// 現在讓我們看看 String 的版本：
// fn main() {
//     let s1 = String::from("hello");
//     let s2 = s1;
// }
// 一個 String 由三個部分組成，如圖中左側所示：一個指向儲存字串內容記憶體的指標、它的長度和它的容量。這些資料是儲存在stack上的，但圖右的內容則是儲存在heap上。
// 長度(len)指的是存放字符串所需的byte數
// 容量(capacity)則是 String 從分配器(OS)那裡總共獲得內存的byte數

// 稍早我們提到當變數離開作用域時，Rust 會自動呼叫 drop 函式並清理該變數在heap上的資料。
// 但圖示 4-2 顯示兩個資料指標都指向相同位置，這會造成一個問題。當 s2 與 s1 都離開作用域時，它們都會嘗試釋放相同的記憶體。
// 這被稱呼為雙重釋放（double free）錯誤，也是我們之前提過的錯誤之一。釋放記憶體兩次可能會導致記憶體損壞，進而造成安全漏洞。

// 為了保障記憶體安全，在此情況中 Rust 還會再做一件重要的事。
// 在 let s2 = s1; 之後，Rust 就不再將 s1 視爲有效。
// 因此當 s1 離開作用域時，Rust 不需要釋放任何東西。
// 請看看如果在 s2 建立之後繼續使用 s1 會發生什麼事，以下程式就執行不了：

// fn main(){
//     let s1 = String::from("hello");
//     let s2 = s1; // move

//     println!("{}, world!", s1);
// }

// 你會得到像這樣的錯誤，因為 Rust 會防止你使用無效的參考：

// ```error
// $ cargo run
//    Compiling ownership v0.1.0 (file:///projects/ownership)
// error[E0382]: borrow of moved value: `s1`
//  --> src/main.rs:5:28
//   |
// 2 |     let s1 = String::from("hello");
//   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
// 3 |     let s2 = s1;
//   |              -- value moved here
// 4 |
// 5 |     println!("{}, world!", s1);
//   |                            ^^ value borrowed here after move
//   |
//   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

// For more information about this error, try `rustc --explain E0382`.
// error: could not compile `ownership` due to previous error

// ```
// 如果你在其他語言聽過
// 淺拷貝（shallow copy）
// 深拷貝（deep copy）
// 拷貝指標、長度和容量而沒有拷貝實際內容這樣的概念應該就相近於淺拷貝。
// 但因為 Rust 同時又無效化第一個變數，我們不會叫此為淺拷貝，而是稱此動作為移動（move）。
// 所以 只有 s2 有效的話，當只有s2離開作用域，就只有它會釋放heap
// 除此之外，這邊還表達了另一個設計決策：Rust 不會自動將創建資料的「深拷貝」。因此任何自動的拷貝動作都可以被視為是對執行效能影響很小的。

// 變數與資料互動的方式：克隆（Clone）

// 要是我們真的想深拷貝 String 在heap上的資料而非僅是stack資料的話，我們可以使用一個常見的方法叫做 clone
// fn main(){
//     let s1 = String::from("hello");
//     let s2 = s1.clone(); // clone主要針對 heap 上的數據

//     println!("{}, {}", s1, s2);
// }

// 只在堆疊上的資料：拷貝（Copy）(複製)

// fn main() {
//     let x = 5;
//     let y = x;

//     println!("x = {}, y = {}", x, y); // x 仍是有效的
// }
// 但這段程式碼似乎和我們剛學的互相矛盾：我們沒有呼叫 clone，但 x 卻仍是有效的，沒有移動到 y。
// 原因是因為像整數這樣的型別在編譯時是已知大小，所以只會存在在堆疊上。
// 所以要拷貝一份實際數值的話是很快的。這也讓我們沒有任何理由要讓 x 在 y 建立後被無效化。

// Rust 有個特別的標記叫做 Copy 特徵（trait）可以用在"標記"像整數這樣完全存放在stack上的型別。
// 如果一個型別 實現 Copy 特徵的話，那麼舊的變數(變量)在賦值給其他變數(變量)後仍然會是有效的。
// 如果某個型別在數值離開作用域時 實現了Drop trait，Rust 不允許我們讓此型別實現 Copy 特徵。
// 這裡的"實現""特徵" 等同於 "作""Copy"這件事

// 哪些型別有實作 Copy 特徵呢？
// 基本原則是任何簡單地純量數值都可以實作 Copy，且不需要分配記憶體或任何形式資源的型別也有實作 Copy。
// 以下是一些有實作 Copy 的型別：
//     所有整數型別像是 u32。
//     布林型別 bool，它只有數值 true 與 false。
//     所有浮點數型別像是 f64。
//     字元型別 char。
//     元組，但要求 包含的型別也都要有實作 Copy 才行。比如 (i32, i32) 就有實作 Copy，但 (i32, String) 則無。

